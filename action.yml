# action.yml
name: 'Main Guardian Agent'
description: 'Analyzes PR diffs against the main branch using Gemini AI and comments on the PR with the analysis.'
author: 'Ispx'

branding:
  icon: 'anchor'
  color: 'black'

# Define as entradas que a action aceita
inputs:
  gemini-api-key:
    description: 'API Key for Google Gemini.'
    required: true
  github-token:
    description: 'GitHub token for posting comments and checking out code. Defaults to github.token.'
    required: true
    default: ${{ github.token }} # Usa o token padrão do workflow

# Define como a action será executada (usando passos compostos)
runs:
  using: 'composite'
  steps:
    # 1. Checkout do código do repositório onde a action está rodando
    #    Precisamos do histórico completo para comparar com 'main'
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ inputs.github-token }}
        fetch-depth: 0 # Busca todo o histórico para poder comparar branches

    # 2. Script principal para analisar o diff e chamar a API Gemini
    - name: Analyze Diff and Generate Report
      id: analyze # Dá um ID ao passo para referenciar outputs se necessário no futuro
      shell: bash
      run: |
        # Verifica se jq está instalado (dependência)
        if ! command -v jq &> /dev/null
        then
            echo "jq could not be found. Please install jq on the runner."
            exit 1
        fi
        # Verifica se curl está instalado (dependência)
        if ! command -v curl &> /dev/null
        then
            echo "curl could not be found. Please install curl on the runner."
            exit 1
        fi

        echo "Starting analysis..."
        BASE_BRANCH_NAME="main" # Nome da branch base
        # Tenta determinar a branch base remota (geralmente origin/main)
        BASE_BRANCH=$(git rev-parse --abbrev-ref origin/HEAD | sed 's/origin\///')
        if [ -z "$BASE_BRANCH" ]; then
          echo "Could not determine the default remote branch. Assuming 'main'."
          BASE_BRANCH="main"
        fi
        echo "Base branch identified as: origin/$BASE_BRANCH"

        # Garante que a branch base remota está atualizada localmente
        git fetch origin $BASE_BRANCH --no-tags # Evita buscar tags desnecessárias
        BASE_REF="origin/$BASE_BRANCH"
        HEAD_REF="HEAD" # O commit atual do PR

        # Define as mensagens do sistema para a IA (mantidas aqui para simplicidade)
        # TODO: Considerar tornar estas mensagens inputs da action para maior flexibilidade
        system_msg_1="Você é responsável por proteger a branch main das novas alterações que serão implementadas, para isso você precisa realizar uma análise criteriosa das novas alterações que serão implementadas."
        system_msg_2="Seu objetivo é identificar possíveis bugs, vulnerabilidades, alterações críticas que possam afetar as funcionalidades já existentes na branch principal $BASE_REF, sugerir melhorias/refatorações nas implementações da branch atual e por fim gerar um score de aprovação entre 0 a 10 para aprovação das novas mudanças mudanças, porém caso exista uma mudança critica ou uma grande vulnerabilidade o scode deve ser 0."
        system_msg_3="Use icons para demarcar cada tipo de análise, por exemplo, um icone expecifico para anlaise de bugs, outro para vulnerabilidades, etc. Formate a saída em Markdown."

        # Pega a lista de arquivos alterados
        echo "Identifying changed files between $BASE_REF and $HEAD_REF..."
        changed_files=$(git diff --name-only $BASE_REF $HEAD_REF)

        if [ -z "$changed_files" ]; then
          echo "No changes detected between $BASE_REF and $HEAD_REF."
          # Cria um arquivo de análise vazio para evitar erro no passo de comentário
          echo "Nenhuma alteração detectada para análise." > analysis.txt
          exit 0 # Sai com sucesso, pois não há nada a analisar
        fi

        echo "Changed files:"
        echo "$changed_files"
        echo "---"

        # Variável para armazenar todas os retornos da IA.
        all_outputs="#Analyse Main Guardian Agent\n\n\\n\n"

        # Itera sobre cada arquivo alterado para gerar relatório de análise.
        for file in $changed_files; do
          echo "Analyzing file: $file"
          # Extrai conteúdo atual do arquivo na branch do PR
          # Usar --no-prefix para caminhos mais limpos no diff
          diff_output=$(git diff --no-prefix $BASE_REF $HEAD_REF -- "$file")

          # Se o diff estiver vazio (ex: apenas mudança de modo), pula a análise para este arquivo
          if [ -z "$diff_output" ]; then
            echo "Skipping $file (no content changes detected)."
            continue
          fi

          # Cria o payload para requisição Gemini
          # Nota: A API pode ter limites no tamanho do diff. Tratar erros ou dividir diffs grandes pode ser necessário.
          json_payload=$(jq -n \
          --arg diff "$diff_output" \
          --arg msg1 "$system_msg_1" \
          --arg msg2 "$system_msg_2" \
          --arg msg3 "$system_msg_3" \
            '{
              system_instruction: {
                parts: [
                  { text: $msg1 },
                  { text: $msg2 },
                  { text: $msg3 }
                ]
              },
              contents: [
                {
                  parts: [
                    { text: $diff }
                  ]
                }
              ],
              generationConfig: {
                temperature: 0.5,
                topP: 0.8,
                topK: 10
              }
            }'
          )

          # Envia o payload para a IA Gemini
          # Adiciona -sS para silenciar progresso mas mostrar erros, e --fail para falhar em erros HTTP
          response=$(curl -sS --fail --location "https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${{ inputs.gemini-api-key }}" \
            --header 'Content-Type: application/json' \
            --data-raw "$json_payload")

          # Verifica se o curl falhou
          if [ $? -ne 0 ]; then
            echo "Error calling Gemini API for file $file. Skipping analysis for this file."
            echo "Response was: $response" # Loga a resposta (pode conter detalhes do erro)
            all_outputs+="### Arquivo: \`$file\`\n⚠️ **Erro ao analisar este arquivo.**\n\n"
            continue # Pula para o próximo arquivo
          fi

          # Extrai as mensagens de retorno (assume estrutura de sucesso)
          # Adiciona verificação se o caminho existe no JSON antes de extrair
          output_text=$(echo "$response" | jq -r '.candidates[0].content.parts[0].text // "Erro: Resposta da IA não encontrada ou em formato inesperado."')

          # Armazena a mensagem na variável
          all_outputs+="### Arquivo: \`$file\`\n$output_text\n\n---\n\n"

        done

        echo "Analysis complete. Saving to analysis.txt"
        # Salva a análise em um arquivo que será usado no próximo passo
        # Usar >> $GITHUB_STEP_SUMMARY para adicionar ao resumo do Job (opcional)
        echo -e "$all_outputs" > analysis.txt
        echo "Analysis saved."

    # 3. Comenta no Pull Request com o resultado da análise
    - name: Comment on Pull Request
      shell: bash
      # Garante que GITHUB_EVENT_PATH está disponível e é um PR
      # A action só roda em 'pull_request', então isso deve ser seguro.
      env:
        GH_TOKEN: ${{ inputs.github-token }} # Usa o token passado como input
        PR_NUMBER: ${{ github.event.pull_request.number }}
        REPO_FULL_NAME: ${{ github.repository }}
      run: |
        echo "Posting comment to PR #$PR_NUMBER"
        # Verifica se o número do PR foi obtido
        if [ -z "$PR_NUMBER" ]; then
          echo "Error: Could not get Pull Request number."
          exit 1
        fi

        # Lê o conteúdo da análise e escapa para JSON
        # Usar jq -Rs . é uma forma robusta de converter texto em string JSON
        body_content=$(cat analysis.txt)
        if [ -z "$body_content" ]; then
          echo "Analysis file is empty. Skipping comment."
          exit 0
        fi
        json_body=$(echo "$body_content" | jq -Rs .)

        # Monta o payload JSON final para a API do GitHub
        post_data="{\"body\": $json_body}"

        # URL da API para comentar no PR (issue)
        comments_url="https://api.github.com/repos/$REPO_FULL_NAME/issues/$PR_NUMBER/comments"

        # Faz a requisição POST para a API do GitHub
        curl_response=$(curl -sS --fail -w "%{http_code}" -X POST \
          -H "Authorization: Bearer $GH_TOKEN" \
          -H "Accept: application/vnd.github.v3+json" \
          -H "Content-Type: application/json" \
          -d "$post_data" \
          "$comments_url" -o /dev/null) # -o /dev/null descarta o corpo da resposta

        http_code=$(echo "$curl_response")

        if [ "$http_code" -ge 200 ] && [ "$http_code" -lt 300 ]; then
          echo "Successfully posted comment to PR #$PR_NUMBER (HTTP $http_code)."
        else
          echo "Error posting comment to PR #$PR_NUMBER. HTTP Status Code: $http_code"
          # Considerar logar mais detalhes se a API retornar um corpo de erro
          exit 1
        fi

# (Opcional) Definir outputs se a action precisar retornar valores
# outputs:
#   analysis-result:
#     description: 'The full analysis text generated.'
#     value: ${{ steps.analyze.outputs.analysis_file_path }} # Exemplo, precisaria ajustar script para setar output
